## Problem

You need to encode binary data as Base64 for transmission over text-only channels, or decode Base64 strings back to binary data.

## Solution

### Basic Base64

```zig
{{#include ../../../code/03-advanced/06-data-encoding/recipe_6_8.zig:basic_base64}}
```

### URL Safe Base64

```zig
{{#include ../../../code/03-advanced/06-data-encoding/recipe_6_8.zig:url_safe_base64}}
```

### Streaming Base64

```zig
{{#include ../../../code/03-advanced/06-data-encoding/recipe_6_8.zig:streaming_base64}}
```

## Discussion

### URL-Safe Base64

Use URL-safe encoding for filenames and URLs:

```zig
pub fn encodeBase64Url(allocator: std.mem.Allocator, data: []const u8) ![]u8 {
    const encoder = std.base64.url_safe.Encoder;
    const encoded_len = encoder.calcSize(data.len);

    const encoded = try allocator.alloc(u8, encoded_len);
    errdefer allocator.free(encoded);

    return encoder.encode(encoded, data);
}

pub fn decodeBase64Url(allocator: std.mem.Allocator, encoded: []const u8) ![]u8 {
    const decoder = std.base64.url_safe.Decoder;
    const decoded_len = try decoder.calcSizeForSlice(encoded);

    const decoded = try allocator.alloc(u8, decoded_len);
    errdefer allocator.free(decoded);

    try decoder.decode(decoded, encoded);
    return decoded;
}

test "URL-safe base64" {
    const allocator = std.testing.allocator;

    const data = [_]u8{ 0xFF, 0xEF, 0xBE };

    const encoded = try encodeBase64Url(allocator, &data);
    defer allocator.free(encoded);

    // URL-safe uses '-' and '_' instead of '+' and '/'
    try std.testing.expect(std.mem.indexOf(u8, encoded, "+") == null);
    try std.testing.expect(std.mem.indexOf(u8, encoded, "/") == null);

    const decoded = try decodeBase64Url(allocator, encoded);
    defer allocator.free(decoded);

    try std.testing.expectEqualSlices(u8, &data, decoded);
}
```

### Encoding Without Padding

Remove padding characters:

```zig
pub fn encodeBase64NoPad(allocator: std.mem.Allocator, data: []const u8) ![]u8 {
    const encoder = std.base64.standard_no_pad.Encoder;
    const encoded_len = encoder.calcSize(data.len);

    const encoded = try allocator.alloc(u8, encoded_len);
    errdefer allocator.free(encoded);

    return encoder.encode(encoded, data);
}

test "base64 without padding" {
    const allocator = std.testing.allocator;

    const data = "Hello";

    const encoded = try encodeBase64NoPad(allocator, data);
    defer allocator.free(encoded);

    // Should not end with '='
    try std.testing.expect(encoded[encoded.len - 1] != '=');
    try std.testing.expectEqualStrings("SGVsbG8", encoded);
}
```

### Streaming Base64 Encoding

Encode large data in chunks:

```zig
pub fn encodeBase64Stream(
    writer: anytype,
    data: []const u8,
    chunk_size: usize,
) !void {
    const encoder = std.base64.standard.Encoder;

    // Adjust chunk size to be multiple of 3 for proper Base64 encoding
    const adjusted_chunk = (chunk_size / 3) * 3;
    if (adjusted_chunk == 0) return error.ChunkTooSmall;

    var i: usize = 0;
    while (i < data.len) {
        const is_last = (i + adjusted_chunk >= data.len);
        const end = if (is_last) data.len else i + adjusted_chunk;
        const chunk = data[i..end];

        const encoded_len = encoder.calcSize(chunk.len);
        var buffer: [4096]u8 = undefined;

        _ = encoder.encode(buffer[0..encoded_len], chunk);
        try writer.writeAll(buffer[0..encoded_len]);

        i = end;
    }
}

test "streaming base64 encoding" {
    const allocator = std.testing.allocator;

    const data = "The quick brown fox jumps over the lazy dog";

    var list = std.ArrayList(u8){};
    errdefer list.deinit(allocator);

    try encodeBase64Stream(list.writer(allocator), data, 10);

    const encoded = try list.toOwnedSlice(allocator);
    defer allocator.free(encoded);

    // Verify it decodes correctly
    const decoded = try decodeBase64(allocator, encoded);
    defer allocator.free(decoded);

    try std.testing.expectEqualStrings(data, decoded);
}
```

### Decoding with Validation

Validate Base64 input:

```zig
pub fn isValidBase64(input: []const u8) bool {
    const decoder = std.base64.standard.Decoder;

    // Check length
    if (input.len == 0) return true;
    if (input.len % 4 != 0) return false;

    // Try to allocate and decode to validate
    var buffer: [4096]u8 = undefined;
    if (input.len / 4 * 3 > buffer.len) return false;

    const size = decoder.calcSizeForSlice(input) catch return false;
    decoder.decode(buffer[0..size], input) catch return false;

    return true;
}

test "validate base64" {
    try std.testing.expect(isValidBase64("SGVsbG8="));
    try std.testing.expect(isValidBase64("SGVsbG8sIFdvcmxkIQ=="));

    try std.testing.expect(!isValidBase64("SGVsb!!!"));
    try std.testing.expect(!isValidBase64("Not valid"));
}
```

### Encoding Binary Data

Handle arbitrary binary data:

```zig
pub fn encodeBinaryToBase64(
    allocator: std.mem.Allocator,
    data: []const u8,
) ![]u8 {
    const encoder = std.base64.standard.Encoder;
    const encoded_len = encoder.calcSize(data.len);

    const encoded = try allocator.alloc(u8, encoded_len);
    errdefer allocator.free(encoded);

    return encoder.encode(encoded, data);
}

test "encode binary data" {
    const allocator = std.testing.allocator;

    const binary = [_]u8{ 0x00, 0xFF, 0x42, 0xAA, 0x55 };

    const encoded = try encodeBinaryToBase64(allocator, &binary);
    defer allocator.free(encoded);

    const decoded = try decodeBase64(allocator, encoded);
    defer allocator.free(decoded);

    try std.testing.expectEqualSlices(u8, &binary, decoded);
}
```

### Fixed Buffer Encoding

Encode into a fixed-size buffer:

```zig
pub fn encodeBase64Buf(data: []const u8, out: []u8) ![]u8 {
    const encoder = std.base64.standard.Encoder;
    const encoded_len = encoder.calcSize(data.len);

    if (out.len < encoded_len) {
        return error.BufferTooSmall;
    }

    return encoder.encode(out[0..encoded_len], data);
}

test "fixed buffer encoding" {
    const data = "Hello, World!";
    var buffer: [256]u8 = undefined;

    const encoded = try encodeBase64Buf(data, &buffer);

    try std.testing.expectEqualStrings("SGVsbG8sIFdvcmxkIQ==", encoded);
}

test "buffer too small" {
    const data = "Hello, World!";
    var buffer: [10]u8 = undefined;

    const result = encodeBase64Buf(data, &buffer);
    try std.testing.expectError(error.BufferTooSmall, result);
}
```

### Decoding Whitespace-Tolerant

Handle Base64 with whitespace:

```zig
pub fn decodeBase64Lenient(
    allocator: std.mem.Allocator,
    encoded: []const u8,
) ![]u8 {
    // Remove whitespace
    var cleaned = std.ArrayList(u8){};
    errdefer cleaned.deinit(allocator);

    for (encoded) |char| {
        if (!std.ascii.isWhitespace(char)) {
            try cleaned.append(allocator, char);
        }
    }

    const clean_data = try cleaned.toOwnedSlice(allocator);
    defer allocator.free(clean_data);

    return decodeBase64(allocator, clean_data);
}

test "decode with whitespace" {
    const allocator = std.testing.allocator;

    const encoded = "SGVs bG8s\nIFdv cmxk\r\nIQ==";

    const decoded = try decodeBase64Lenient(allocator, encoded);
    defer allocator.free(decoded);

    try std.testing.expectEqualStrings("Hello, World!", decoded);
}
```

### Best Practices

**Encoding:**
- Use standard Base64 for general purposes
- Use URL-safe variant for URLs and filenames
- Use no-padding variant when padding causes issues
- Consider streaming for large data

**Decoding:**
```zig
// Always validate before decoding
if (!isValidBase64(input)) {
    return error.InvalidBase64;
}

const decoded = try decodeBase64(allocator, input);
defer allocator.free(decoded);
```

**Performance:**
- Pre-allocate buffers when size is known
- Use fixed buffers for small data
- Stream large data to avoid memory spikes

**Security:**
- Validate input length to prevent DoS
- Be aware of padding oracle attacks in cryptographic contexts
- Clean up sensitive data after decoding

### Related Functions

- `std.base64.standard.Encoder` - Standard Base64 encoder
- `std.base64.standard.Decoder` - Standard Base64 decoder
- `std.base64.url_safe.Encoder` - URL-safe Base64 encoder
- `std.base64.url_safe.Decoder` - URL-safe Base64 decoder
- `std.base64.standard_no_pad` - Base64 without padding
- `std.ascii.isWhitespace()` - Check for whitespace characters
