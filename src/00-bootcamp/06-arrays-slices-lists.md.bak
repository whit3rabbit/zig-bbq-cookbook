---
title: "Arrays, ArrayLists, and Slices (CRITICAL)"
description: "The #1 confusion point for Zig beginners - understanding the three fundamental sequence types"
tags: ["beginner", "critical", "arrays", "slices", "ArrayList", "strings"]
---

# Arrays, ArrayLists, and Slices

## Problem

You're coming from Python, JavaScript, or Java where you have a single "list" or "array" type that handles everything. In Zig, there are THREE different sequence types, and mixing them up causes endless confusion.

When do you use `[N]T`? When `[]T`? When `ArrayList`? Why are strings `[]const u8`? This is the #1 stumbling block for Zig beginners.

## Solution

Zig has three fundamental sequence types, each for different use cases:

1. **Fixed Arrays `[N]T`** - Compile-time size, stack-allocated, no allocator needed
2. **Slices `[]T`** - Runtime views into arrays (pointer + length), don't own memory
3. **ArrayList** - Growable arrays that need an allocator, own their memory

The confusion comes because Python's `list` or Java's `ArrayList` tries to be all three. Zig separates these concerns for performance and clarity.

## Discussion

### Part 1: Fixed Arrays `[N]T`

Arrays have compile-time known size. **The size is part of the type.**

```zig
test "fixed arrays have compile-time size" {
    // The size is in the type
    const arr1: [3]i32 = [_]i32{ 1, 2, 3 };
    const arr2: [5]i32 = [_]i32{ 1, 2, 3, 4, 5 };

    // These are different types!
    // const same: [3]i32 = arr2;  // error: type mismatch

    try testing.expectEqual(@as(usize, 3), arr1.len);
    try testing.expectEqual(@as(usize, 5), arr2.len);
}
```

Key point: `[3]i32` and `[5]i32` are **completely different types**. You can't assign one to the other.

**Arrays live on the stack:**

```zig
test "arrays live on the stack" {
    // No allocator needed - arrays are value types
    const numbers = [_]i32{ 10, 20, 30, 40 };

    // You can pass arrays by value (they get copied)
    const sum = sumArray(numbers);

    try testing.expectEqual(@as(i32, 100), sum);
}

fn sumArray(arr: [4]i32) i32 {
    var total: i32 = 0;
    for (arr) |n| {
        total += n;
    }
    return total;
}
```

**Arrays cannot grow:**

```zig
test "arrays cannot grow or shrink" {
    var arr = [_]i32{ 1, 2, 3 };

    // Can modify elements
    arr[0] = 10;
    try testing.expectEqual(@as(i32, 10), arr[0]);

    // But cannot change size
    // arr.append(4);  // No such method!
    // The size is fixed at compile time
}
```

**When to use fixed arrays:**
- Size is known at compile time
- Small, fixed collections
- Want stack allocation (fast, no allocator)
- Returning fixed-size data from functions

### Part 2: Slices `[]T`

Slices are "views" into arrays - they're a pointer plus a length. They don't own the memory.

```zig
test "slices are views into arrays" {
    const array = [_]i32{ 1, 2, 3, 4, 5 };

    // Create a slice (view) of the array
    const slice: []const i32 = &array;

    // Slice knows its length at runtime
    try testing.expectEqual(@as(usize, 5), slice.len);
    try testing.expectEqual(@as(i32, 1), slice[0]);
}
```

**Slicing syntax:**

```zig
test "slicing an array" {
    const array = [_]i32{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // Get a sub-slice [start..end]
    const middle: []const i32 = array[3..7]; // [3, 4, 5, 6]

    try testing.expectEqual(@as(usize, 4), middle.len);
    try testing.expectEqual(@as(i32, 3), middle[0]);
    try testing.expectEqual(@as(i32, 6), middle[3]);
}
```

**Why slices are useful - generic functions:**

```zig
test "slices can be passed to functions" {
    const array = [_]i32{ 10, 20, 30 };

    // Functions that take slices work with any array size
    const sum1 = sumSlice(&array);
    try testing.expectEqual(@as(i32, 60), sum1);

    const other = [_]i32{ 5, 15 };
    const sum2 = sumSlice(&other);
    try testing.expectEqual(@as(i32, 20), sum2);
}

fn sumSlice(slice: []const i32) i32 {
    var total: i32 = 0;
    for (slice) |n| {
        total += n;
    }
    return total;
}
```

The function takes `[]const i32` (slice) instead of `[N]i32` (fixed array), so it works with **any** array size.

**Mutable slices:**

```zig
test "mutable slices" {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Mutable slice - can modify through it
    const slice: []i32 = &array;
    slice[0] = 99;

    try testing.expectEqual(@as(i32, 99), array[0]);
}
```

**Important: Slices don't own memory:**

```zig
test "slices don't own memory" {
    const array = [_]i32{ 1, 2, 3 };
    const slice: []const i32 = &array;

    // The slice is just a view - array owns the memory
    // When array goes out of scope, slice becomes invalid
    try testing.expectEqual(array.len, slice.len);
}
```

This is crucial: a slice is just a pointer and length. When the underlying array is freed, the slice becomes a dangling pointer.

**When to use slices:**
- Function parameters (accept any array size)
- Working with subsections of arrays
- Passing array data without copying
- As return types when you don't own the memory

### Part 3: ArrayList - Growable Arrays

When you need to add or remove elements, use `ArrayList`. This is like Python's `list` or Java's `ArrayList`.

```zig
test "ArrayList needs an allocator" {
    // ArrayList requires an allocator to manage memory
    var list = std.ArrayList(i32){};
    defer list.deinit(testing.allocator);

    // Can grow dynamically
    try list.append(testing.allocator, 1);
    try list.append(testing.allocator, 2);
    try list.append(testing.allocator, 3);

    try testing.expectEqual(@as(usize, 3), list.items.len);
    try testing.expectEqual(@as(i32, 1), list.items[0]);
}
```

Key difference: **ArrayList needs an allocator**. No allocator in Zig is free - you must explicitly provide one.

**ArrayList vs Fixed Array:**

```zig
test "ArrayList vs fixed array" {
    // Fixed array - size known at compile time
    const fixed = [_]i32{ 1, 2, 3 };

    // ArrayList - size known at runtime, can grow
    var list = std.ArrayList(i32){};
    defer list.deinit(testing.allocator);

    try list.append(testing.allocator, 1);
    try list.append(testing.allocator, 2);
    try list.append(testing.allocator, 3);

    // Can add more!
    try list.append(testing.allocator, 4);
    try testing.expectEqual(@as(usize, 4), list.items.len);
}
```

**ArrayList operations:**

```zig
test "ArrayList operations" {
    var list = std.ArrayList(i32){};
    defer list.deinit(testing.allocator);

    // Append items
    try list.append(testing.allocator, 10);
    try list.append(testing.allocator, 20);
    try list.append(testing.allocator, 30);

    try testing.expectEqual(@as(usize, 3), list.items.len);

    // Access items through .items slice
    try testing.expectEqual(@as(i32, 10), list.items[0]);
    try testing.expectEqual(@as(i32, 20), list.items[1]);

    // Pop removes last element
    const last = list.pop();
    try testing.expectEqual(@as(i32, 30), last);
    try testing.expectEqual(@as(usize, 2), list.items.len);
}
```

**ArrayList gives you a slice via `.items`:**

```zig
test "ArrayList .items is a slice" {
    var list = std.ArrayList(i32){};
    defer list.deinit(testing.allocator);

    try list.append(testing.allocator, 5);
    try list.append(testing.allocator, 10);
    try list.append(testing.allocator, 15);

    // .items gives you a slice of the contents
    const slice: []i32 = list.items;

    // Can use slice operations
    try testing.expectEqual(@as(usize, 3), slice.len);

    // Can pass to functions expecting slices
    const sum = sumSlice(slice);
    try testing.expectEqual(@as(i32, 30), sum);
}
```

This is powerful: ArrayList owns the memory and manages growth, but you can get a slice view for passing to functions.

**When to use ArrayList:**
- Need to grow or shrink at runtime
- Building up data dynamically
- Don't know size in advance
- Like Python `list` or Java `ArrayList`

### Strings in Zig

Strings complicate things because they use all three types!

**String literals are special arrays:**

```zig
test "string literals are special arrays" {
    // String literal type: *const [N:0]u8
    // *const = pointer to const
    // [N:0]u8 = array of N bytes with null terminator
    const hello: *const [5:0]u8 = "hello";

    try testing.expectEqual(@as(usize, 5), hello.len);
    try testing.expectEqual(@as(u8, 'h'), hello[0]);
}
```

The `:0` means "null-terminated" (sentinel-terminated) for C compatibility.

**Usually, work with strings as slices:**

```zig
test "strings as slices" {
    const hello = "hello";

    // Can convert to slice
    const slice: []const u8 = hello;

    try testing.expectEqual(@as(usize, 5), slice.len);

    // Can slice strings
    const ello: []const u8 = hello[1..];
    try testing.expect(std.mem.eql(u8, ello, "ello"));
}
```

Most functions take `[]const u8` (slice of bytes) for strings.

**Building strings dynamically:**

```zig
test "building strings with ArrayList" {
    // For dynamic strings, use ArrayList(u8)
    var string = std.ArrayList(u8){};
    defer string.deinit(testing.allocator);

    try string.appendSlice(testing.allocator, "Hello");
    try string.appendSlice(testing.allocator, ", ");
    try string.appendSlice(testing.allocator, "World!");

    try testing.expect(std.mem.eql(u8, string.items, "Hello, World!"));
}
```

### Comparison Table

| Type | Size | Location | Allocator? | Can Grow? | Owns Memory? |
|------|------|----------|------------|-----------|--------------|
| `[N]T` | Compile-time | Stack | No | No | Yes |
| `[]T` | Runtime | N/A (view) | No | No | No |
| `ArrayList` | Runtime | Heap | Yes | Yes | Yes |

**Practical examples:**

```zig
test "comparing the three types" {
    // 1. Fixed Array [N]T
    const fixed: [3]i32 = [_]i32{ 1, 2, 3 };
    // - Size known at compile time
    // - Lives on stack
    // - Cannot grow
    // - No allocator needed
    try testing.expectEqual(@as(usize, 3), fixed.len);

    // 2. Slice []T
    const slice_view: []const i32 = &fixed;
    // - View into array
    // - Size known at runtime
    // - Just pointer + length
    // - Doesn't own memory
    try testing.expectEqual(@as(usize, 3), slice_view.len);

    // 3. ArrayList
    var dynamic = std.ArrayList(i32){};
    defer dynamic.deinit(testing.allocator);
    try dynamic.append(testing.allocator, 1);
    try dynamic.append(testing.allocator, 2);
    try dynamic.append(testing.allocator, 3);
    // - Can grow and shrink
    // - Owns memory (needs allocator)
    // - .items gives you a slice
    // - Like Python list or Java ArrayList
    try testing.expectEqual(@as(usize, 3), dynamic.items.len);
}
```

### Decision Tree

**Need to add/remove elements?**
- Yes ’ Use `ArrayList`
- No ’ Continue

**Size known at compile time?**
- Yes ’ Use `[N]T` (fixed array)
- No ’ Use `[]T` (slice parameter for functions)

**For strings:**
- String literal ’ Let Zig infer (becomes `*const [N:0]u8`)
- Function parameter ’ Use `[]const u8` (slice)
- Building dynamically ’ Use `ArrayList(u8)`

### Common Patterns

**Function parameters - use slices:**
```zig
fn processItems(items: []const i32) void {
    // Works with any array size or ArrayList.items
}
```

**Return fixed arrays:**
```zig
fn getCoordinates() [3]f32 {
    return [_]f32{ 1.0, 2.0, 3.0 };
}
```

**Build up data - use ArrayList:**
```zig
fn collectResults(allocator: std.mem.Allocator) !std.ArrayList(i32) {
    var results = std.ArrayList(i32){};
    // ... add items ...
    return results;  // Caller owns it now
}
```

### Common Mistakes

**Trying to assign different array sizes:**
```zig
const a: [3]i32 = [_]i32{1, 2, 3};
const b: [5]i32 = a;  // error: type mismatch!
```

**Forgetting to deinit ArrayList:**
```zig
var list = std.ArrayList(i32){};
// ... use list ...
// Memory leak! Need: defer list.deinit(allocator);
```

**Using dangling slices:**
```zig
fn getBadSlice() []const i32 {
    const arr = [_]i32{1, 2, 3};  // Stack array
    return &arr;  // Returns dangling pointer!
}
```

**Confusing slice syntax:**
```zig
const arr = [_]i32{1, 2, 3};
const slice: []const i32 = &arr;  //  Correct
const wrong: []const i32 = arr;   //  Wrong (missing &)
```

## See Also

- Recipe 0.5: Primitive Data and Basic Arrays - Fixed array basics
- Recipe 0.9: Understanding Pointers and References - How slices work internally
- Recipe 0.12: Understanding Allocators - Why ArrayList needs one
- Recipe 2.8: Combining and Concatenating Strings - Working with string slices

Full compilable example: `code/00-bootcamp/recipe_0_6.zig`
